<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Scrollama: Sticky Overlay Example</title>
    <meta name="description" content="Scrollama: Sticky Overlay Example" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="style.css" />
    <link rel="stylesheet" href="https://use.typekit.net/etl6wzo.css">
  </head>

  <body>
    <script src="slides.js" defer></script>
    <script src="memento.js"></script>
   

 <nav>
    <ul id="menu">
      <li><a href="#intro">INTRO</a></li>
      <li><a href="#grafico">GRAFICO</a></li>
      <li><a href="#evidenze">EVIDENZE</a></li>
      <li><a href="#conclusione">CONCLUSIONE</a></li>
  </ul>
</nav>


<br /><br />

      <img id="titolo" src="figo.mp4" autoplay="0"/>


      <br /><br /> 
      <br /><br />
      <br /><br />
      <br /><br />


      
      <div class="line-container">
        <svg width="1144" height="375" viewBox="0 0 1144 375" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M0.5 1.99935C225.075 -0.575318 1052.8 75.4186 1130.06 113.638C1207.33 151.858 890.57 129.563 722.532 113.638C478.326 101.909 34.2021 90.5233 211.349 138.813C388.496 187.102 593.491 169.041 673.845 153.974C717.556 144.725 834.031 131.775 950.245 153.974C1095.51 181.724 840.313 164.273 895.279 181.724C950.245 199.174 1185.81 219.771 1068.03 234.647C950.245 249.523 -133.368 237.222 94.3477 307.596C276.52 363.895 704.207 374.537 895.279 372.821" stroke="#FF7A00" stroke-width="3"/>
          </svg>
          
      </div>
      <script>

        let path = document.querySelector ("path")
        let pathLength = path.getTotalLength()

        path.style.strokeDasharray = pathLength + " " + pathLength;

        path.style.strokeDashoffset = pathLength;

        window.addEventListener("scroll", () => {

          // what % down is it?
          var scrollPercentage = (document.documentElement.scrollTop + document.body.scrollTop) / (document.documentElement.scrollHeight - document.documentElement.clientHeight);
          
          // Length to offset the dashes
          var drawLength = pathLength * scrollPercentage;

          // Draw in reverse
          path.style.strokeDashoffset = pathLength - drawLength;

        })
        
      </script>

<a name="intro"></a>
<p></p>
<br /><br /> 
<br /><br />
<br /><br />

<article>
  <div class="step11" >
    <p>
      Oggi considerato come uno dei film <br>più importanti del nuovo
      millennio, <br>nel 2002 ricevette anche le candidature <br>ai premi <font color="d24f2c"><b>Oscar</b></font>
      per miglior sceneggiatura originale <br>e miglior montaggio.
    </p>
  </div>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br />
  <div class="step2" >
    <p>
      I protagonisti dei film di Nolan <br>presentano sempre un rapporto
      complesso <br>con <font color="d24f2c"><b>realtà</b></font> e <font color="d24f2c"><b>memoria</b></font>, e il regista si diverte a
      raccontarne <br>le gesta giocando con il tempo, o per meglio dire,<br>
      utilizzando una struttura temporale non lineare.
    </p>
  </div>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />

  <br /><br /><br /><br />
  <div class="step12" >
    <p>
      Leonard Shelby in Memento <br> mette in discussione i suoi <font color="d24f2c"><b>ricordi</b></font>, <br> il
      tempo continua a giocare <br> un ruolo chiave nella storia.
    </p>
  </div>
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />

  <br /><br /><br /><br />
  <div class="step2" >
    <p>
      Il regista ci fa credere che ci dobbiamo fidare <br> solo dei <font color="d24f2c"><b>tatuaggi</b></font>
      e delle <font color="d24f2c"><b>polaroid</b></font>, <br> dati come <font color="d24f2c"><b>evidenze</b></font>, perché il protagonista <br> non
      avendo memoria a lungo termine <br> li utilizza come strumenti che gli
      permettono <br>di orientarsi nella vita quotidiana.
    </p>
  </div>
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br />
  <div class="stepcg" >
    <p>
      Ma possiamo ritenere questi dati davvero oggettivi?
    </p>
    <!-- al centro grande-->
  </div>
  <br /><br /><br /><br /> <br />
  <br /><br /><br /><br /> <br /><br /><br /><br /> <br /><br /><br /><br />
  <div class="stepc" >
    <p>
      Per capirlo, o almeno provarci, abbiamo provato a rileggere la storia da un punto di vista diverso...
    </p>
    <!-- al centro grande-->
  </div>
  <br /><br /><br /><br /> <br />
  <br /><br /><br /><br /> <br /><br /><br /><br /> <br /><br /><br /><br />
  <div class="stepcg" >
  <p>
Partiamo dal montaggio di Nolan
  </p>
  <!-- al centro grande-->
</div>
<br /><br /><br /><br /> <br />
<br /><br /><br /><br /> <br /><br /><br /><br /> <br /><br /><br /><br />

  <div class="step13" >
    <p>
      Il <font color="d24f2c"><b>montaggio</b></font> prevede che la storia <br> alterni ogni 15 minuti una
      scena <br> cronologicamente opposta alla precedente. <br>La pellicola parte
      quindi dalla fine <br> e si conclude poco dopo la metà,<br> alternando
      scene in bianco e nero e a colori.
    </p>
  </div>
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
</article>

<a name="grafico"></a>
<p></p><p></p><p></p><p></p><p></p>
<img id="schema" src="schema.jpg" />

  <br /><br /><br /><br />
  <br /><br /><br /><br /> <br /><br /><br /><br />
  <article>  
  <div class="stepcg" >
    <p>
  Ci siamo chiesti: quanto la soggettività del protagonista interferisce con la presunta veridicità delle evidenze?
    </p>
  </div>
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />

  <br /><br /><br /><br />
  <div class="step11" >
    <p>
      Adesso ti proponiamo un'analisi delle scene <br> ricostruendo l'<font color="d24f2c"><b>ordine cronologico</b></font> degli eventi, <br> attraverso una rilettura delle evidenze: polaroid e tatuaggi,<br>
      che rappresentano l'unico punto di riferimento oggettivo <br> per il protagonista.
    </p>
  </div>
</article>


    <script src="https://unpkg.com/intersection-observer@0.5.1/intersection-observer.js"></script>
    <script type="text/javascript">
      (function (global, factory) {
        typeof exports === "object" && typeof module !== "undefined"
          ? (module.exports = factory())
          : typeof define === "function" && define.amd
          ? define(factory)
          : ((global = global || self), (global.scrollama = factory()));
      })(this, function () {
        "use strict";

        // DOM helper functions

        // public
        function selectAll(selector, parent = document) {
          if (typeof selector === "string") {
            return Array.from(parent.querySelectorAll(selector));
          } else if (selector instanceof Element) {
            return [selector];
          } else if (selector instanceof NodeList) {
            return Array.from(selector);
          } else if (selector instanceof Array) {
            return selector;
          }
          return [];
        }

        // SETUP
        function create(className) {
          const el = document.createElement("div");
          el.className = `scrollama__debug-step ${className}`;
          el.style.position = "fixed";
          el.style.left = "0";
          el.style.width = "100%";
          el.style.zIndex = "9999";

          const p = document.createElement("p");
          p.style.position = "absolute";
          p.style.left = "0";
          p.style.height = "1px";
          p.style.width = "100%";

          el.appendChild(p);
          document.body.appendChild(el);
          return el;
        }

        // UPDATE
        function update({ id, step, marginTop }) {
          const { index, height } = step;
          const className = `scrollama__debug-step--${id}-${index}`;
          let el = document.querySelector(`.${className}`);
          if (!el) el = create(className);

          el.style.top = `${marginTop * -1}px`;
          el.style.height = `${height}px`;
          el.querySelector("p").style.top = `${height / 2}px`;
        }

        function generateId() {
          const alphabet = "abcdefghijklmnopqrstuvwxyz";
          const date = Date.now();
          const result = [];
          for (let i = 0; i < 6; i += 1) {
            const char = alphabet[Math.floor(Math.random() * alphabet.length)];
            result.push(char);
          }
          return `${result.join("")}${date}`;
        }

        function err$1(msg) {
          console.error(`scrollama error: ${msg}`);
        }

        function getIndex(node) {
          return +node.getAttribute("data-scrollama-index");
        }

        function createProgressThreshold(height, threshold) {
          const count = Math.ceil(height / threshold);
          const t = [];
          const ratio = 1 / count;
          for (let i = 0; i < count + 1; i += 1) {
            t.push(i * ratio);
          }
          return t;
        }

        function parseOffset(x) {
          if (typeof x === "string" && x.indexOf("px") > 0) {
            const v = +x.replace("px", "");
            if (!isNaN(v)) return { format: "pixels", value: v };
            else {
              err("offset value must be in 'px' format. Fallback to 0.5.");
              return { format: "percent", value: 0.5 };
            }
          } else if (typeof x === "number" || !isNaN(+x)) {
            if (x > 1) err("offset value is greater than 1. Fallback to 1.");
            if (x < 0) err("offset value is lower than 0. Fallback to 0.");
            return { format: "percent", value: Math.min(Math.max(0, x), 1) };
          }
          return null;
        }

        function indexSteps(steps) {
          steps.forEach((step) =>
            step.node.setAttribute("data-scrollama-index", step.index)
          );
        }

        function getOffsetTop(node) {
          const { top } = node.getBoundingClientRect();
          const scrollTop = window.pageYOffset;
          const clientTop = document.body.clientTop || 0;
          return top + scrollTop - clientTop;
        }

        let currentScrollY;
        let comparisonScrollY;
        let direction;

        function onScroll(container) {
          const scrollTop = container
            ? container.scrollTop
            : window.pageYOffset;

          if (currentScrollY === scrollTop) return;
          currentScrollY = scrollTop;
          if (currentScrollY > comparisonScrollY) direction = "down";
          else if (currentScrollY < comparisonScrollY) direction = "up";
          comparisonScrollY = currentScrollY;
        }

        function setupScroll(container) {
          currentScrollY = 0;
          comparisonScrollY = 0;
          document.addEventListener("scroll", () => onScroll(container));
        }

        function scrollama() {
          let cb = {};

          let id = generateId();
          let steps = [];
          let globalOffset;
          let containerElement;
          let rootElement;

          let progressThreshold = 0;

          let isEnabled = false;
          let isProgress = false;
          let isDebug = false;
          let isTriggerOnce = false;

          let exclude = [];

          /* HELPERS */
          function reset() {
            cb = {
              stepEnter: () => {},
              stepExit: () => {},
              stepProgress: () => {},
            };
            exclude = [];
          }

          function handleEnable(shouldEnable) {
            if (shouldEnable && !isEnabled) updateObservers();
            if (!shouldEnable && isEnabled) disconnectObservers();
            isEnabled = shouldEnable;
          }

          /* NOTIFY CALLBACKS */
          function notifyProgress(element, progress) {
            const index = getIndex(element);
            const step = steps[index];
            if (progress !== undefined) step.progress = progress;
            const response = { element, index, progress, direction };
            if (step.state === "enter") cb.stepProgress(response);
          }

          function notifyStepEnter(element, check = true) {
            const index = getIndex(element);
            const step = steps[index];
            const response = { element, index, direction };

            step.direction = direction;
            step.state = "enter";

            // if (isPreserveOrder && check && direction !== "up")
            //   notifyOthers(index, "above");
            // if (isPreserveOrder && check && direction === "up")
            //   notifyOthers(index, "below");

            if (!exclude[index]) cb.stepEnter(response);
            if (isTriggerOnce) exclude[index] = true;
          }

          function notifyStepExit(element, check = true) {
            const index = getIndex(element);
            const step = steps[index];

            if (!step.state) return false;

            const response = { element, index, direction };

            if (isProgress) {
              if (direction === "down" && step.progress < 1)
                notifyProgress(element, 1);
              else if (direction === "up" && step.progress > 0)
                notifyProgress(element, 0);
            }

            step.direction = direction;
            step.state = "exit";

            cb.stepExit(response);
          }

          /* OBSERVERS - HANDLING */
          function resizeStep([entry]) {
            const index = getIndex(entry.target);
            const step = steps[index];
            const h = entry.target.offsetHeight;
            if (h !== step.height) {
              step.height = h;
              disconnectObserver(step);
              updateStepObserver(step);
              updateResizeObserver(step);
            }
          }

          function intersectStep([entry]) {
            onScroll(containerElement);

            const { isIntersecting, target } = entry;
            if (isIntersecting) notifyStepEnter(target);
            else notifyStepExit(target);
          }

          function intersectProgress([entry]) {
            const index = getIndex(entry.target);
            const step = steps[index];
            const { isIntersecting, intersectionRatio, target } = entry;
            if (isIntersecting && step.state === "enter")
              notifyProgress(target, intersectionRatio);
          }

          /*  OBSERVERS - CREATION */
          function disconnectObserver({ observers }) {
            Object.keys(observers).map((name) => {
              observers[name].disconnect();
            });
          }

          function disconnectObservers() {
            steps.forEach(disconnectObserver);
          }

          function updateResizeObserver(step) {
            const observer = new ResizeObserver(resizeStep);
            observer.observe(step.node);
            step.observers.resize = observer;
          }

          function updateResizeObservers() {
            steps.forEach(updateResizeObserver);
          }

          function updateStepObserver(step) {
            const h = window.innerHeight;
            const off = step.offset || globalOffset;
            const factor = off.format === "pixels" ? 1 : h;
            const offset = off.value * factor;
            const marginTop = step.height / 2 - offset;
            const marginBottom = step.height / 2 - (h - offset);
            const rootMargin = `${marginTop}px 0px ${marginBottom}px 0px`;
            const root = rootElement;

            const threshold = 0.5;
            const options = { rootMargin, threshold, root };
            const observer = new IntersectionObserver(intersectStep, options);

            observer.observe(step.node);
            step.observers.step = observer;

            if (isDebug) update({ id, step, marginTop, marginBottom });
          }

          function updateStepObservers() {
            steps.forEach(updateStepObserver);
          }

          function updateProgressObserver(step) {
            const h = window.innerHeight;
            const off = step.offset || globalOffset;
            const factor = off.format === "pixels" ? 1 : h;
            const offset = off.value * factor;
            const marginTop = -offset + step.height;
            const marginBottom = offset - h;
            const rootMargin = `${marginTop}px 0px ${marginBottom}px px`;

            const threshold = createProgressThreshold(
              step.height,
              progressThreshold
            );
            const options = { rootMargin, threshold };
            const observer = new IntersectionObserver(
              intersectProgress,
              options
            );

            observer.observe(step.node);
            step.observers.progress = observer;
          }

          function updateProgressObservers() {
            steps.forEach(updateProgressObserver);
          }

          function updateObservers() {
            disconnectObservers();
            updateResizeObservers();
            updateStepObservers();
            if (isProgress) updateProgressObservers();
          }

          /* SETUP */
          const S = {};

          S.setup = ({
            step,
            parent,
            offset = 0.5,
            threshold = 4,
            progress = false,
            once = false,
            debug = false,
            container = undefined,
            root = null,
          }) => {
            setupScroll(container);

            steps = selectAll(step, parent).map((node, index) => ({
              index,
              direction: undefined,
              height: node.offsetHeight,
              node,
              observers: {},
              offset: parseOffset(node.dataset.offset),
              top: getOffsetTop(node),
              progress: 0,
              state: undefined,
            }));

            if (!steps.length) {
              err$1("no step elements");
              return S;
            }

            isProgress = progress;
            isTriggerOnce = once;
            isDebug = debug;
            progressThreshold = Math.max(1, +threshold);
            globalOffset = parseOffset(offset);
            containerElement = container;
            rootElement = root;

            reset();
            indexSteps(steps);
            handleEnable(true);
            return S;
          };

          S.enable = () => {
            handleEnable(true);
            return S;
          };

          S.disable = () => {
            handleEnable(false);
            return S;
          };

          S.destroy = () => {
            handleEnable(false);
            reset();
            return S;
          };

          S.resize = () => {
            updateObservers();
            return S;
          };

          S.offset = (x) => {
            if (x === null || x === undefined) return globalOffset.value;
            globalOffset = parseOffset(x);
            updateObservers();
            return S;
          };

          S.onStepEnter = (f) => {
            if (typeof f === "function") cb.stepEnter = f;
            else err$1("onStepEnter requires a function");
            return S;
          };

          S.onStepExit = (f) => {
            if (typeof f === "function") cb.stepExit = f;
            else err$1("onStepExit requires a function");
            return S;
          };

          S.onStepProgress = (f) => {
            if (typeof f === "function") cb.stepProgress = f;
            else err$1("onStepProgress requires a function");
            return S;
          };
          return S;
        }

        return scrollama;
      });
    </script>
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script>
      var main = document.querySelector("main");
      var scrolly = main.querySelector("#scrolly");
      var sticky = scrolly.querySelector(".sticky-thing");
      var article = scrolly.querySelector("article");
      var steps = article.querySelectorAll(".step");

      var scroller = scrollama();

      function handleStepEnter(response) {
        var el = response.element;

        steps.forEach((step) => step.classList.remove("is-active"));
        el.classList.add("is-active");

        sticky.querySelector("p").innerText = el.dataset.step;

        // Aggiungi linee arancioni l'1 dice quante linee mettere al 1 step
        createOrangeLines(response.index + 1); // Passa l'indice dello step per determinare il numero di linee
      }

      function createOrangeLines(lineCount) {
        var linesData = Array.from({ length: lineCount }, (_, i) => i + 1);

        var isVertical = Math.random() < 0.2; // Decide se le linee saranno orizzontali o verticali

        var lines = d3
          .select(".orange-lines")
          .selectAll("line")
          .data(linesData);

        lines
          .enter()
          .append("line")
          .attr("class", "orange-line")
          .attr("x1", isVertical ? () => Math.random() * sticky.offsetWidth : 0)
          .attr(
            "y1",
            isVertical ? 0 : () => Math.random() * sticky.offsetHeight
          )
          .attr(
            "x2",
            isVertical
              ? () => Math.random() * sticky.offsetWidth
              : sticky.offsetWidth
          )
          .attr(
            "y2",
            isVertical ? 0 : () => Math.random() * sticky.offsetHeight
          );
        lines.exit().remove();
      }

      function init() {
        scroller
          .setup({
            step: "#scrolly article .step",
            offset: 0.33,
            debug: true,
          })
          .onStepEnter(handleStepEnter);

        window.addEventListener;
        window.addEventListener("resize", scroller.resize);
      }
      init();
    </script>


<br /><br /><br /><br /><br /><br /><br /><br /><br /><br /> <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />




    <br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
    <!-- INIZIO PARTE POLAROID-->
    <a name="evidenze"></a>

    <section id="content">
      
      
      <div class="image-container">
        <div class="section active" id="section0">
          <div class="img-container">
            <img
              src="polaroidtattoo/teddyaterra.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section1">
          <div class="img-container">
            <img
              src="polaroidtattoo/p6v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section2">
          <div class="img-container">
            <img
              src="polaroidtattoo/p2+s.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section3">
          <div class="img-container">
            <img
              src="polaroidtattoo/p1v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <br /><br /><br /><br />
        <div class="section" id="section4">
          <div class="img-container">
            <div id="cambioimmagine">
            <img
              src="polaroidtattoo/p7v.jpg"
              alt="Memento Imagen 1"
              class="img1"
            />
            <img
            src="polaroidtattoo/p9v.jpg"
            alt="Memento Imagen 1"
            class="img2"
          />
        </div>
          </div>
        </div>
        <div class="section" id="section5">
          <div class="img-container">
            <img
              src="polaroidtattoo/p6v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section6">
          <div class="img-container">
            <img
              src="polaroidtattoo/tattoo4.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section7">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section8">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section9">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section10">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section11">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section12">
          <div class="img-container">
            <img
              src="polaroidtattoo/p5v.jpg"
              alt="Memento Imagen 1"
              class="img"
            />
          </div>
        </div>
        <div class="section" id="section13">
          <div class="img-container">
            <div id="cambioimmagine">
            <img
              src="polaroidtattoo/p2vr.jpg"
              alt="Memento Imagen 1"
              class="img1"
            />
            <img
            src="polaroidtattoo/rTedn1.jpg"
            alt="Memento Imagen 1"
            class="img2"
          />
          </div>
          </div>
        </div>
      </div>

      <!-- agg div per aggiungere pallino-->
      <div class="box-container">
        <div class="left-column">
          <div class="box2 left-box active"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box2 left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>
          <div class="box left-box"></div>

        </div>
        <div class="right-column">
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box active"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box2 right-box"></div>
          <div class="box right-box"></div>
          <div class="box right-box"></div>
        </div>
      </div>
    </section>
    <br><br><br><br><br>
  
        <br /><br /><br /><br />

        <a name="conclusione"></a>


        <article>
          <div class="stepcg" >
            <p>
              Nolan si sofferma sull'idea di verità: che cos'è realmente?
            </p>
          </div>
        
          <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
          <br /><br /><br /><br />
          <div class="step2" >
            <p>
              Il regista dimostra che la linea che separa realtà e immaginazione è estremamente labile.
               Sta allo spettatore comprenderlo: quello di Nolan, infatti, 
               può essere definito una sorta di cinema interattivo, in cui lo spettatore, 
               a differenza di Leonard, può sentirsi libero di fidarsi delle proprie percezioni e 
               sensazione nell’attribuire un significato alle cose.</p>
          </div>
        
          <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
        
          <br /><br /><br /><br />
          <div class="step12" >
            <p>
             Forse Leonard non è interessato a scoprire la verità, 
              quanto piuttosto a raggiungere una verità che si adatti alle proprie necessità. </p>
          </div>
          <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
        
          <br /><br /><br /><br />
          <div class="stepcg" >
            <p>
            Quanto ci si può fidare realmente dei nostri stessi ricordi? </p>
          </div>
          <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
           </article>
        
          
        
          <br><br><br><br><br>
  
          <br /><br /><br /><br />


    <footer>
      <p>© 2023 Memento Website</p>
    </footer>

    <script>
      // document.addEventListener("DOMContentLoaded", function () {
      //   const images = document.querySelectorAll(".movie-image");
      //   const circles = document.querySelectorAll(".circle");

      //   let currentIndex = 0;

      //   function showImage(index) {
      //     images.forEach((image) => image.classList.remove("visible"));
      //     images[index].classList.add("visible");

      //     circles.forEach((circle) => circle.classList.remove("active"));
      //     circles[index].classList.add("active");
      //   }

      //   function nextImage() {
      //     currentIndex = (currentIndex + 1) % images.length;
      //     showImage(currentIndex);
      //   }

      //   document
      //     .getElementById("nextButton")
      //     .addEventListener("click", nextImage);

      //   showImage(currentIndex);
      // });
    </script>

 
  </body>
</html>
